{"name":"Wallbox","type":"com.fibaro.binarySwitch","apiVersion":"1.3","initialProperties":{"viewLayout":{"$jason":{"body":{"header":{"style":{"height":"0"},"title":"quickApp_device_332"},"sections":{"items":[{"components":[{"components":[{"name":"button_stop","style":{"weight":"0.25"},"text":"II","type":"button","visible":false},{"name":"button_start","style":{"weight":"0.25"},"text":"⏻","type":"button","visible":false},{"name":"button_reschedule","style":{"weight":"0.25"},"text":"⏰","type":"button","visible":false},{"name":"button_refresh","style":{"weight":"0.25"},"text":"↺","type":"button","visible":true}],"style":{"weight":"1.2"},"type":"horizontal"},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"status","style":{"weight":"1.2"},"text":"-","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"name":"label_max_charging_current","style":{"weight":"1.2"},"text":"Power Limit","type":"label","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"},{"components":[{"max":"100","min":"0","name":"max_charging_current","style":{"weight":"1.2"},"text":"","type":"slider","visible":true},{"style":{"weight":"0.5"},"type":"space"}],"style":{"weight":"1.2"},"type":"vertical"}]}},"head":{"title":"quickApp_device_332"}}},"uiView":[{"components":[{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_stop"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_stop"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_stop"]},"type":"deviceAction"}]},"name":"button_stop","style":{"weight":"0.25"},"text":"II","type":"button","visible":false},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_start"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_start"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_start"]},"type":"deviceAction"}]},"name":"button_start","style":{"weight":"0.25"},"text":"⏻","type":"button","visible":false},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_reschedule"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_reschedule"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_reschedule"]},"type":"deviceAction"}]},"name":"button_reschedule","style":{"weight":"0.25"},"text":"⏰","type":"button","visible":false},{"eventBinding":{"onLongPressDown":[{"params":{"actionName":"UIAction","args":["onLongPressDown","button_refresh"]},"type":"deviceAction"}],"onLongPressReleased":[{"params":{"actionName":"UIAction","args":["onLongPressReleased","button_refresh"]},"type":"deviceAction"}],"onReleased":[{"params":{"actionName":"UIAction","args":["onReleased","button_refresh"]},"type":"deviceAction"}]},"name":"button_refresh","style":{"weight":"0.25"},"text":"↺","type":"button","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"status","style":{"weight":"1.0"},"text":"-","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"name":"label_max_charging_current","style":{"weight":"1.0"},"text":"Power Limit","type":"label","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"},{"components":[{"eventBinding":{"onChanged":[{"params":{"actionName":"UIAction","args":["onChanged","max_charging_current","$event.value"]},"type":"deviceAction"}]},"max":"100","min":"0","name":"max_charging_current","style":{"weight":"1.0"},"text":"","type":"slider","visible":true}],"style":{"weight":"1.0"},"type":"horizontal"}],"useUiView":true,"uiCallbacks":[{"callback":"onStop","eventType":"onReleased","name":"button_stop"},{"callback":"","eventType":"onLongPressDown","name":"button_stop"},{"callback":"","eventType":"onLongPressReleased","name":"button_stop"},{"callback":"onStart","eventType":"onReleased","name":"button_start"},{"callback":"","eventType":"onLongPressDown","name":"button_start"},{"callback":"","eventType":"onLongPressReleased","name":"button_start"},{"callback":"onReschedule","eventType":"onReleased","name":"button_reschedule"},{"callback":"","eventType":"onLongPressDown","name":"button_reschedule"},{"callback":"","eventType":"onLongPressReleased","name":"button_reschedule"},{"callback":"onRefresh","eventType":"onReleased","name":"button_refresh"},{"callback":"","eventType":"onLongPressDown","name":"button_refresh"},{"callback":"","eventType":"onLongPressReleased","name":"button_refresh"},{"callback":"onChangeMaxChargingCurrent","eventType":"onChanged","name":"max_charging_current"}],"quickAppVariables":[{"name":"username","type":"string","value":"-"},{"name":"password","type":"password","value":"********"},{"name":"chargerId","type":"string","value":"-"}],"typeTemplateInitialized":true},"initialInterfaces":[],"files":[{"name":"main","isMain":true,"isOpen":true,"content":"-- Fibaro HC3 Quick App for Wallbox\n-- Version 1.0\n\nlocal translations = {\n    en = {\n        labels = {\n            power_limit = \"Power limit\",\n        },\n        errors = {\n            unknown = \"Unexpected error\",\n            var_username_undefined = \"Variable 'username' not defined\",\n            var_password_undefined = \"Variable 'password' not defined\",\n            var_chargerId_undefined = \"Variable 'chargerId' not defined\",\n            [1] = \"Error connecting to Wallbox API\",\n            [2] = \"Error getting token from Wallbox API, check username and password\",\n            [3] = \"Error getting status from Wallbox API, check chargerId (ie. serial number)\",\n            [4] = \"Error updating charger from Wallbox API\",\n        },\n        status = {\n            unknown = \"Unknown status\",\n            waiting = \"Waiting for status ...\",\n            [0] = \"Disconnected\",\n            [14] = \"Error\",\n            [15] = \"Error\",\n            [161] = \"Ready\",\n            [162] = \"Ready\",\n            [163] = \"Disconnected\",\n            [164] = \"Waiting\",\n            [165] = \"Locked\",\n            [166] = \"Updating\",\n            [177] = \"Scheduled\",\n            [178] = \"Paused\",\n            [179] = \"Scheduled\",\n            [180] = \"Waiting for car demand\",\n            [181] = \"Waiting for car demand\",\n            [182] = \"Paused\",\n            [183] = \"Waiting in queue by Power Sharing\",\n            [184] = \"Waiting in queue by Power Sharing\",\n            [185] = \"Waiting in queue by Power Boost\",\n            [186] = \"Waiting in queue by Power Boost\",\n            [187] = \"Waiting MID failed\",\n            [188] = \"Waiting MID safety margin exceeded\",\n            [189] = \"Waiting in queue by Eco-Smart\",\n            [193] = \"Charging\",\n            [194] = \"Charging\",\n            [195] = \"Charging\",\n            [196] = \"Discharging\",\n            [209] = \"Locked\",\n            [210] = \"Locked - Car connected\",\n        },\n    },\n    fr = {\n        labels = {\n            power_limit =\"Limite de puissance\",\n        },\n        errors = {\n            unknown = \"Erreur inattendue\",\n            var_username_undefined = \"Variable 'username' non définie\",\n            var_password_undefined = \"Variable 'password' non définie\",\n            var_chargerId_undefined = \"Variable 'chargerId' non définie\",\n            [1] = \"Erreur lors de la connection à l'API Wallbox\",\n            [2] = \"Erreur lors de la récupération du token depuis l'API Wallbox, vérifiez le login et le mot de passe\",\n            [3] = \"Erreur lors de la récupération du statut depuis l'API Wallbox, vérifiez l'id du chargeur (numéro de série)\",\n            [4] = \"Erreur lors de la mise à jour du chargeur depuis l'API Wallbox\",\n        },\n        status = {\n            unknown = \"Statut inconnu\",\n            waiting = \"En attente du statut ...\",\n            [0] = \"Débranché\",\n            [14] = \"Erreur\",\n            [15] = \"Erreur\",\n            [161] = \"Prêt\",\n            [162] = \"Prêt\",\n            [163] = \"Débranché\",\n            [164] = \"En attendant\",\n            [165] = \"Verrouillé\",\n            [166] = \"Mise à jour en cours\",\n            [177] = \"Programmé\",\n            [178] = \"En pause\",\n            [179] = \"Programmé\",\n            [180] = \"En attente de la demande du véhicule\",\n            [181] = \"En attente de la demande du véhicule\",\n            [182] = \"En pause\",\n            [183] = \"Mis en file d'attente par Power Sharing\",\n            [184] = \"Mis en file d'attente par Power Sharing\",\n            [185] = \"Mis en file d'attente par Power Boost\",\n            [186] = \"Mis en file d'attente par Power Boost\",\n            [187] = \"Échec attente MID\",\n            [188] = \"Marge de sécurité dépassée attente MID\",\n            [189] = \"Mis en file d'attente par Eco-Smart\",\n            [193] = \"En charge\",\n            [194] = \"En charge\",\n            [195] = \"En charge\",\n            [196] = \"En décharge\",\n            [209] = \"Verrouillé\",\n            [210] = \"Verrouillé - Véhicule branché\",\n        },\n    },\n}\n\nfunction QuickApp:statusToString(s)\n    local strStatus = self.trad.status[s]\n    if strStatus then\n        return strStatus\n    end\n    return self.trad.status.unknown\nend\n\nfunction QuickApp:errorToString(e)\n    local strError = self.trad.errors[e]\n    if strError then\n        return strError\n    end\n    return self.trad.errors.unknown\nend\n\nlocal status = {\n    [0] = \"DISCONNECTED\",\n    [14] = \"ERROR\",\n    [15] = \"ERROR\",\n    [161] = \"READY\",\n    [162] = \"READY\",\n    [163] = \"DISCONNECTED\",\n    [164] = \"WAITING\",\n    [165] = \"LOCKED\",\n    [166] = \"UPDATING\",\n    [177] = \"SCHEDULED\",\n    [178] = \"PAUSED\",\n    [179] = \"SCHEDULED\",\n    [180] = \"WAITING_FOR_CAR_DEMAND\",\n    [181] = \"WAITING_FOR_CAR_DEMAND\",\n    [182] = \"PAUSED\",\n    [183] = \"WAITING_IN_QUEUE_BY_POWER_SHARING\",\n    [184] = \"WAITING_IN_QUEUE_BY_POWER_SHARING\",\n    [185] = \"WAITING_IN_QUEUE_BY_POWER_BOOST\",\n    [186] = \"WAITING_IN_QUEUE_BY_POWER_BOOST\",\n    [187] = \"WAITING_MID_FAILED\",\n    [188] = \"WAITING_MID_SAFETY_MARGIN_EXCEEDED\",\n    [189] = \"WAITING_IN_QUEUE_BY_ECO_SMART\",\n    [193] = \"CHARGING\",\n    [194] = \"CHARGING\",\n    [195] = \"CHARGING\",\n    [196] = \"DISCHARGING\",\n    [209] = \"LOCKED\",\n    [210] = \"LOCKED_CAR_CONNECTED\",\n    [999] = \"UNKNOWN\",\n}\n\nfunction QuickApp:statusToEnum(s)\n    local strStatus = status[s]\n    if strStatus then\n        return strStatus\n    end\n    return status[999]\nend\n\nfunction QuickApp:getStatusEnum()\n    return {status[0], status[14], status[161], status[164], status[165], status[179], status[178], status[180], status[183], status[185], status[187], status[188], status[189], status[193], status[196], status[210], status[999]}\nend\n\nfunction QuickApp:getToken(callback)\n    local token = self.wallbox_token\n    if token and token ~= \"-\" then\n        local status, jwt = pcall(jwt.decode_jwt, token)\n        if jwt and jwt.claims and jwt.claims.exp and jwt.claims.username then\n            if jwt.claims.username ~= self.username then\n                trace:debug(\"Renew Token because username from existing Token '\" .. jwt.claims.username  .. \"' is not the same as curent username '\" .. self.username .. \"'\")\n            else\n                if jwt.claims.exp < os.time() then\n                    self:trace(\"Renew Token because existing Token for username '\" .. jwt.claims.username .. \"' is expired since \" .. os.date(\"%c\",jwt.claims.exp))\n                else\n                    self:trace(\"Use existing Token for username '\" .. jwt.claims.username .. \"' because it is still valide and will expire at \" .. os.date(\"%c\",jwt.claims.exp))\n                    callback(true, token)\n                    return\n                end\n            end\n        else\n            self:trace(\"Renew Token because existing Token is not valid\")\n        end\n    end\n    self.wallbox_token = \"-\"\n\tself:trace(\"Getting token from Wallbox API ...\")\n    wallbox:getToken(\n        self.username,\n        self.password,\n        function(sucess, token_or_err)\n            if sucess then\n\t\t\t\tself:trace(\"New Token loaded\")\n                self.wallbox_token = token_or_err\n            end\n            callback(sucess, token_or_err)\n        end\n    )\nend\n\nfunction QuickApp:updateCharger(jsonInput, callback)\n    self:getToken(\n        function(success, token_or_err)\n            if (success) then\n\t\t\t\tself:trace(\"Updating charger from Wallbox API ...\")\n                wallbox:updateCharger(\n                    token_or_err,\n                    self.charger_id,\n                    jsonInput,\n                    function(success, status_or_err)\n                        if success then\n\t\t\t\t\t\t\tself:trace(\"Charger updated\")\n                            self:synchroniseQuickAppState(status_or_err)\n                        end\n                        callback(success, status_or_err)\n                    end\n                )\n            else\n                callback(false, token_or_err)\n            end\n        end\n    )\nend\n\nfunction QuickApp:getChargerStatus(callback)\n    self:getToken(\n        function(success, token_or_err)\n            if (success) then\n\t\t\t\tself:trace(\"Getting charger status from Wallbox API ...\")\n                wallbox:getChargerStatus(\n                    token_or_err,\n                    self.charger_id,\n                    function(success, status_or_err)\n\t\t\t\t\t\tself:trace(\"Charger status loaded\")\n                        callback(success, status_or_err)\n                    end\n                )\n            else\n                callback(false, token_or_err)\n            end\n        end\n    )\nend\n\nfunction QuickApp:setMaxChargingCurrent(current, callback)\n    self:updateCharger({maxChargingCurrent = current}, callback)\nend\n\nfunction QuickApp:lockCharger(callback)\n    self:updateCharger({locked = 1}, callback)\nend\n\nfunction QuickApp:unlockCharger(callback)\n    self:updateCharger({locked = 0}, callback)\nend\n\nfunction QuickApp:resumeCharger(callback)\n    self:updateCharger({action = 1}, callback)\nend\n\nfunction QuickApp:pauseCharger(callback)\n    self:updateCharger({action = 2}, callback)\nend\n\nfunction QuickApp:rescheduleCharger(callback)\n    self:updateCharger({action = 9}, callback)\nend\n\nfunction QuickApp:synchroniseQuickAppState(status)\n    if not tools:checkVG(\"Wallbox_\"..self.charger_id) then\n        tools:createVG(\"Wallbox_\"..self.charger_id, self:statusToEnum(status.data.chargerData.status), self:getStatusEnum())\n    else\n        tools:setVG(\"Wallbox_\"..status.data.chargerData.id, self:statusToEnum(status.data.chargerData.status))\n    end\n    -- Lock / Unlock\n    if (status.data.chargerData.locked == 1) then\n        if (fibaro.getValue(self.id,\"value\") ~= false) then\n            self:updateProperty(\"value\", false)\n            --hub.alert('push', {2}, self.wallbox_name ..' Locked')\n        end\n    else\n        if (fibaro.getValue(self.id,\"value\") ~= true) then\n            self:updateProperty(\"value\", true)\n            --hub.alert('push', {2}, self.wallbox_name .. ' Unlocked')\n        end\n    end\n\n    -- Charging current\n    local maxAvailableCurrent = status.data.chargerData.maxAvailableCurrent\n    if (maxAvailableCurrent ~= tools.getView(self,\"max_charging_current\",\"max\")) then -- max\n        self:updateView(\"max_charging_current\",\"max\", tostring(maxAvailableCurrent))\n    end\n    local maxChargingCurrent = status.data.chargerData.maxChargingCurrent\n    if (maxChargingCurrent ~= tools.getView(self,\"max_charging_current\",\"value\")) then -- value\n        self:updateView(\"max_charging_current\",\"value\", tostring(maxChargingCurrent))\n    end\n\n    if (os.time() >= self.actions_locked_until) then\n        -- Status\n        local wbStatus = status.data.chargerData.status\n        self:updateView(\"status\",\"text\", self:statusToString(wbStatus))\n\n        if wbStatus == 193 or wbStatus == 194 or wbStatus == 195 then\n            -- Charging\n            self:updateView(\"button_start\",\"visible\", false)\n            self:updateView(\"button_stop\",\"visible\", true)\n        elseif wbStatus == 177 or wbStatus == 178 or wbStatus == 179 or wbStatus == 182 then\n            -- Paused or Scheduled\n            self:updateView(\"button_start\",\"visible\", true)\n            self:updateView(\"button_stop\",\"visible\", false)\n        else\n            self:updateView(\"button_start\",\"visible\", false)\n            self:updateView(\"button_stop\",\"visible\", false)\n        end\n        if wbStatus == 178 or wbStatus == 182 then\n            -- Paused\n            self:updateView(\"button_reschedule\",\"visible\", true)\n        else\n            self:updateView(\"button_reschedule\",\"false\", false)\n        end\n    end\nend\n\n-- Lock start/stop action button and status label for at less 5s\nfunction QuickApp:delayRefreshStatus()\n    self.actions_locked_until = os.time() + 5 * 1000\n    self:updateView(\"button_start\",\"visible\", false)\n    self:updateView(\"button_stop\",\"visible\", false)\n    self:updateView(\"button_reschedule\",\"visible\", false)\n    self:updateView(\"status\",\"text\", self.trad.status.waiting)\n    -- wait 5s to refresh status\n    fibaro.setTimeout(\n        5*1000,\n        function()\n            self.actions_locked_until = 0\n            self:refreshChargerStatus()\n            -- wait 2s more to rerefresh status\n            fibaro.setTimeout(\n                2*1000,\n                function()\n                    self:refreshChargerStatus()\n                end\n            )\n        end\n    )\nend\n\nfunction QuickApp:refreshChargerStatus(callback)\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                self:synchroniseQuickAppState(status_or_err)\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n            if callback then\n                callback(success, status_or_err)\n            end\n        end\n    )\nend\n\nfunction QuickApp:loop()\n    fibaro.setTimeout(\n        1*60*1000,\n        function()\n            self:refreshChargerStatus()\n            self:loop()\n        end\n    ) -- all 1 min\nend\n\nfunction QuickApp:initAndLoop()\n    self:refreshChargerStatus(\n        function(success, status_or_err)\n            if success then\n                self:loop()\n            end\n        end\n    )\nend\n\nfunction QuickApp:onInit()\n    self:trace(\"-----------------------------\")\n    self:trace(\"Initialisation Wallbox QA\")\n    self:trace(\"-----------------------------\")\n\n    self.language = api.get(\"/settings/info\").defaultLanguage or nil\n    self.trad = translations[string.lower(self.language)]\n    if not self.trad then\n        self.language = \"en\"\n        self.trad = translations[\"en\"]\n    end\n\n    -- Initialise max charging current slider\n    self:updateView(\"max_charging_current\",\"min\",\"6\")\n    self:updateView(\"max_charging_current\",\"min\",\"6\")\n    self:updateView(\"max_charging_current\",\"max\", \"32\")\n    self:updateView(\"max_charging_current\", \"value\", \"32\")\n    self:updateView(\"label_max_charging_current\", \"text\", self.trad.labels.power_limit)\n\n    -- Get variables from Quickapp config\n    self.username = self:getVariable(\"username\")\n    self.password = self:getVariable(\"password\")\n    self.charger_id = self:getVariable(\"chargerId\")\n    if not self.username or self.username == \"\" or self.username == \"-\" then\n        self:error(self.trad.errors.var_username_undefined)\n        self:updateView(\"status\", \"text\", self.trad.errors.var_username_undefined)\n    elseif not self.password or self.password == \"\" or self.password == \"-\" then\n        self:error(self.trad.errors.var_password_undefined)\n        self:updateView(\"status\", \"text\", self.trad.errors.var_password_undefined)\n    elseif not self.charger_id or self.charger_id == \"\" or self.charger_id == \"-\" then\n        self:error(self.trad.errors.var_chargerId_undefined)\n        self:updateView(\"status\", \"text\", self.trad.errors.var_chargerId_undefined)\n    else\n        -- Get Quickapp name\n        self.wallbox_name = api.get(\"/devices/\"..plugin.mainDeviceId).name\n\n        self.wallbox_token = \"-\"\n        self.actions_locked_until = 0\n\n        self:initAndLoop()\n    end\nend\n\nfunction QuickApp:turnOn()\n    self:trace(\"binary switch turned on\")\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                if status_or_err.data.chargerData.locked == 1 then\n                    self:unlockCharger(\n                        function(success, status_or_err)\n                            if success then\n                                self:synchroniseQuickAppState(status_or_err)\n                            else\n\t\t\t\t\t\t\t\tself:error(status_or_err.msg)\n                                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n                            end\n                        end\n                    )\n                else\n                    self:synchroniseQuickAppState(status_or_err)\n                end\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n\nfunction QuickApp:turnOff()\n    self:trace(\"binary switch turned off\")\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                if status_or_err.data.chargerData.locked == 0 then\n                    self:lockCharger(\n                        function(success, status_or_err)\n                            if success then\n                                self:synchroniseQuickAppState(status_or_err)\n                            else\n\t\t\t\t\t\t\t\tself:error(status_or_err.msg)\n                                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n                            end\n                        end\n                    )\n                else\n                    self:synchroniseQuickAppState(status_or_err)\n                end\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n\nfunction QuickApp:onStop(event)\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                local wbStatus = status_or_err.data.chargerData.status\n                if wbStatus == 193 or wbStatus == 194 or wbStatus == 195 then\n                    self:pauseCharger(\n                        function(success, status_or_err)\n                            if success then\n                                self:delayRefreshStatus()\n                            else\n\t\t\t\t\t\t\t\tself:error(status_or_err.msg)\n                                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n                            end\n                        end\n                    )\n                end\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n\nfunction QuickApp:onStart(event)\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                local wbStatus = status_or_err.data.chargerData.status\n                if wbStatus == 177 or wbStatus == 178 or wbStatus == 179 or wbStatus == 182 then\n                    self:resumeCharger(\n                        function(success, status_or_err)\n                            if success then\n                                self:delayRefreshStatus()\n                            else\n\t\t\t\t\t\t\t\tself:error(status_or_err.msg)\n                                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n                            end\n                        end\n                    )\n                end\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n\nfunction QuickApp:onReschedule(event)\n    self:getChargerStatus(\n        function(success, status_or_err)\n            if success then\n                local wbStatus = status_or_err.data.chargerData.status\n                if wbStatus == 178 or wbStatus == 182 then\n                    self:rescheduleCharger(\n                        function(success, status_or_err)\n                            if success then\n                                self:delayRefreshStatus()\n                            else\n\t\t\t\t\t\t\t\tself:error(status_or_err.msg)\n                                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n                            end\n                        end\n                    )\n                end\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n\nfunction QuickApp:onRefresh(event)\n    self:refreshChargerStatus()\nend\n\nfunction QuickApp:onChangeMaxChargingCurrent(event)\n    local maxChargingCurrent = event.values[1]\n    self:trace(\"Change max charging current \" .. maxChargingCurrent)\n    self:setMaxChargingCurrent(\n        tonumber(maxChargingCurrent),\n        function(success, status_or_err)\n            if success then\n                self:synchroniseQuickAppState(status_or_err)\n            else\n\t\t\t\tself:error(status_or_err.msg)\n                self:updateView(\"status\", \"text\", self:errorToString(status_or_err.code))\n            end\n        end\n    )\nend\n"},{"name":"wallbox","isMain":false,"isOpen":true,"content":"-- Wallbox API specifications from https://github.com/SKB-CGN/wallbox\n\n-- Errors codes\n-- 1 = Error connecting to Wallbox API\n-- 2 = Error getting token from Wallbox API, check username and password\n-- 3 = Error getting status from Wallbox API, check chargerId\n-- 4 = Error updating charger from Wallbox API\n\n-- Status codes\n-- 0 = Disconnected\n-- 14 = Error\n-- 15 = Error\n-- 161 = Ready\n-- 162 = Ready\n-- 163 = Disconnected\n-- 164 = Waiting\n-- 165 = Locked\n-- 166 = Updating\n-- 177 = Scheduled\n-- 178 = Paused\n-- 179 = Scheduled\n-- 180 = Waiting for car demand\n-- 181 = Waiting for car demand\n-- 182 = Paused\n-- 183 = Waiting in queue by Power Sharing\n-- 184 = Waiting in queue by Power Sharing\n-- 185 = Waiting in queue by Power Boost\n-- 186 = Waiting in queue by Power Boost\n-- 187 = Waiting MID failed\n-- 188 = Waiting MID safety margin exceeded\n-- 189 = Waiting in queue by Eco-Smart\n-- 193 = Charging\n-- 194 = Charging\n-- 195 = Charging\n-- 196 = Discharging\n-- 209 = Locked\n-- 210 = Locked - Car connected\n\nlocal WALLBOX_AUTHENTICATION_URL = \"https://api.wall-box.com/auth/token/user\"\nlocal WALLBOX_CHARGER_URL = \"https://api.wall-box.com/v2/charger/\"\nlocal WALLBOX_CHARGERS_URL = \"https://api.wall-box.com/v3/chargers/\"\nlocal WALLBOX_REMOTE_ACTION = \"/remote-action\"\n\nlocal httpClient = net.HTTPClient()\n\nwallbox = {}\n\nlocal b='ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nlocal function encodeBase64(data)\n    return ((data:gsub('.', function(x) \n        local r,b='',x:byte()\n        for i=8,1,-1 do r=r..(b%2^i-b%2^(i-1)>0 and '1' or '0') end\n        return r;\n    end)..'0000'):gsub('%d%d%d?%d?%d?%d?', function(x)\n        if (#x < 6) then return '' end\n        local c=0\n        for i=1,6 do c=c+(x:sub(i,i)=='1' and 2^(6-i) or 0) end\n        return b:sub(c+1,c+1)\n    end)..({ '', '==', '=' })[#data%3+1])\nend\n\n-- Get token from Wallbox API\nfunction wallbox:getToken(username, password, callback)\n\n \thttpClient:request(WALLBOX_AUTHENTICATION_URL, {\n \t\toptions = {\n \t\t\tmethod = \"POST\",\n         \theaders = {\n                [\"Authorization\"] = \"Basic \" .. encodeBase64(username .. \":\" .. password),\n                [\"Accept\"] = \"application/json, text/plain, */*\",\n                [\"Content-Type\"] = \"application/json;charset=utf-8\",\n \t\t\t}\n \t\t},\n \t\tsuccess = function(response)\n            if response.status ~= 200 then\n                callback(false, {code=2, msg=\"Error getting token from Wallbox API, check username and password\"})\n                return;\n            end\n            local success, json_or_err = pcall(json.decode, response.data)\n         \tif success and json_or_err.jwt then\n                callback(true, json_or_err.jwt)\n        \telse\n                callback(false, {code=2, msg=\"Error getting token from Wallbox API\"})\n            end\n        end, \n        error = function(err)\n            callback(false, {code=1, msg=\"Error connecting to Wallbox API\"})\n        end,\n \t})\nend\n\n-- Get charger status from Wallbox API\nfunction wallbox:getChargerStatus(token, charger_id, callback)\n\n \thttpClient:request(WALLBOX_CHARGER_URL .. charger_id, {\n \t\toptions = {\n \t\t\tmethod = \"GET\",\n         \theaders = {\n                [\"Authorization\"] = \"Bearer \" .. token,\n                [\"Accept\"] = \"application/json, text/plain, */*\",\n                [\"Content-Type\"] = \"application/json;charset=utf-8\",\n \t\t\t}\n \t\t},\n \t\tsuccess = function(response)\n            if response.status ~= 200 then\n                callback(false, {code=3, msg=\"Error getting status from Wallbox API, check charger id (ie. serial number)\"})\n                return;\n            end\n            local success, json_or_err = pcall(json.decode, response.data)\n         \tif success then\n                callback(true, json_or_err)\n        \telse\n                callback(false, {code=3, msg=\"Error getting status from Wallbox API\"})\n            end\n        end, \n        error = function(err)\n            callback(false, {code=1, msg=\"Error connecting to Wallbox API\"})\n        end,\n \t})\nend\n\n-- Update charger from Wallbox API\nfunction wallbox:updateCharger(token, charger_id, jsonInput, callback)\n\n    local meth = \"PUT\"\n    local url = WALLBOX_CHARGER_URL .. charger_id\n\n    if (jsonInput.action) then\n        meth = \"POST\"\n        url = WALLBOX_CHARGERS_URL .. charger_id .. WALLBOX_REMOTE_ACTION\n    end\n\n \thttpClient:request(url, {\n \t\toptions = {\n \t\t\tmethod = meth,\n         \theaders = {\n                [\"Authorization\"] = \"Bearer \" .. token,\n                [\"Accept\"] = \"application/json, text/plain, */*\",\n                [\"Content-Type\"] = \"application/json;charset=utf-8\",\n \t\t\t},\n            data = json.encode(jsonInput)\n \t\t},\n \t\tsuccess = function(response)\n            if response.status ~= 200 then\n                callback(false, {code=4, msg=\"Error updating charger status from Wallbox API : \" .. response.status})\n                return;\n            end\n            local success, json_or_err = pcall(json.decode, response.data)\n         \tif success then\n                if meth == \"PUT\" then\n                    -- API /v2/charger/ return status\n                    callback(true, json_or_err)\n                else\n                    -- API /v3/chargers/ do not return status\n                    self:getChargerStatus(token, charger_id, callback)\n                end\n        \telse\n                callback(false, {code=4, msg=\"Error updating charger status from Wallbox API\"})\n            end\n        end, \n        error = function(err)\n            callback(false, {code=1, msg=\"Error connecting to Wallbox API\"})\n        end,\n \t})\nend\n\n\n"},{"name":"jwt","isMain":false,"isOpen":true,"content":"-- Library provided by Inaiat Henrique https://gist.github.com/inaiat/02bf5d11732d8e4d7b7546399a3a49af\n--\n-- Json Parsing based on https://gist.github.com/tylerneylon/59f4bcf316be525b30ab\n-- Base64 decoding based on wikipedia description of 8/6bit encoding.\n-- base64 char array.. note final 2 chars are for RFC4648-URL encoding\n-- as per JWT spec section 2 terminology 'Base64url Encoding'\nlocal alpha = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'\n-- convert to 6 char long binary string. (max int 64!)\nlocal function toBinaryString(int)\n    if int > 64 then error(\"Bad number \" .. int .. \" to convert to binary\") end\n    local remaining = tonumber(int)\n    local bits = ''\n    for i = 5, 0, -1 do\n        local pow = 2 ^ i\n        if remaining >= pow then\n            bits = bits .. '1'\n            remaining = remaining - pow\n        else\n            bits = bits .. '0'\n        end\n    end\n    return bits\nend\nlocal function fromBinaryString(bits) return tonumber(bits, 2) end\nlocal function decodeBase64(encoded)\n    local bitstr = ''\n    local decoded = ''\n    -- decode chars into bitstring\n    for i = 1, string.len(encoded) do\n        local offset, _ = string.find(alpha, string.sub(encoded, i, i))\n        if offset == nil then\n            error(\"Bad base64 character \" .. string.sub(encoded, i, i))\n        end\n        bitstr = bitstr .. toBinaryString(offset - 1)\n    end\n    -- decode bitstring back to chars\n    for i = 1, string.len(bitstr), 8 do\n        decoded = decoded ..\n                      string.char(fromBinaryString(string.sub(bitstr, i, i + 7)))\n    end\n    return decoded\nend\n\n-- Returns pos, did_find; there are two cases:\n-- 1. Delimiter found: pos = pos after leading space + delim; did_find = true.\n-- 2. Delimiter not found: pos = pos after leading space;     did_find = false.\n-- This throws an error if err_if_missing is true and the delim is not found.\nlocal function skip_delim(str, pos, delim, err_if_missing)\n    pos = pos + #str:match('^%s*', pos)\n    if str:sub(pos, pos) ~= delim then\n        if err_if_missing then\n            error('Expected ' .. delim .. ' near position ' .. pos)\n        end\n        return pos, false\n    end\n    return pos + 1, true\nend\n\n-- Expects the given pos to be the first character after the opening quote.\n-- Returns val, pos; the returned pos is after the closing quote character.\nlocal function parse_str_val(str, pos, val)\n    val = val or ''\n    local early_end_error = 'End of input found while parsing string.'\n    if pos > #str then error(early_end_error) end\n    local c = str:sub(pos, pos)\n    if c == '\"' then return val, pos + 1 end\n    if c ~= '\\\\' then return parse_str_val(str, pos + 1, val .. c) end\n    -- We must have a \\ character.\n    local esc_map = {b = '\\b', f = '\\f', n = '\\n', r = '\\r', t = '\\t'}\n    local nextc = str:sub(pos + 1, pos + 1)\n    if not nextc then error(early_end_error) end\n    return parse_str_val(str, pos + 2, val .. (esc_map[nextc] or nextc))\nend\n\n-- Returns val, pos; the returned pos is after the number's final character.\nlocal function parse_num_val(str, pos)\n    local num_str = str:match('^-?%d+%.?%d*[eE]?[+-]?%d*', pos)\n    local val = tonumber(num_str)\n    if not val then error('Error parsing number at position ' .. pos .. '.') end\n    return val, pos + #num_str\nend\n\n-- json handling\nlocal json = {}\njson.null = {} -- one-off table to represent the null value.\nfunction json.parse(str, pos, end_delim)\n    pos = pos or 1\n    if pos > #str then error('Reached unexpected end of input.') end\n    local pos = pos + #str:match('^%s*', pos) -- Skip whitespace.\n    local first = str:sub(pos, pos)\n    if first == '{' then -- Parse an object.\n        local obj, key, delim_found = {}, true, true\n        pos = pos + 1\n        while true do\n            key, pos = json.parse(str, pos, '}')\n            if key == nil then return obj, pos end\n            if not delim_found then\n                error('Comma missing between object items.')\n            end\n            pos = skip_delim(str, pos, ':', true) -- true -> error if missing.\n            obj[key], pos = json.parse(str, pos)\n            pos, delim_found = skip_delim(str, pos, ',')\n        end\n    elseif first == '[' then -- Parse an array.\n        local arr, val, delim_found = {}, true, true\n        pos = pos + 1\n        while true do\n            val, pos = json.parse(str, pos, ']')\n            if val == nil then return arr, pos end\n            if not delim_found then\n                error('Comma missing between array items.')\n            end\n            arr[#arr + 1] = val\n            pos, delim_found = skip_delim(str, pos, ',')\n        end\n    elseif first == '\"' then -- Parse a string.\n        return parse_str_val(str, pos + 1)\n    elseif first == '-' or first:match('%d') then -- Parse a number.\n        return parse_num_val(str, pos)\n    elseif first == end_delim then -- End of an object or array.\n        return nil, pos + 1\n    else -- Parse true, false, or null.\n        local literals = {\n            ['true'] = true,\n            ['false'] = false,\n            ['null'] = json.null\n        }\n        for lit_str, lit_val in pairs(literals) do\n            local lit_end = pos + #lit_str - 1\n            if str:sub(pos, lit_end) == lit_str then\n                return lit_val, lit_end + 1\n            end\n        end\n        local pos_info_str = 'position ' .. pos .. ': ' ..\n                                 str:sub(pos, pos + 10)\n        error('Invalid json syntax starting at ' .. pos_info_str)\n    end\nend\n\njwt = {}\nfunction jwt.decode_jwt(jwt)\n    local i = 0\n    local result = {}\n    for match in (jwt .. '.'):gmatch(\"(.-)%.\") do\n        result[i] = decodeBase64(match)\n        i = i + 1\n    end\n    -- header\n    local head = json.parse(result[0])\n    -- claims\n    local claims = json.parse(result[1])\n    return {head = head, claims = claims}\nend\n"},{"name":"tools","isMain":false,"isOpen":true,"content":"tools = {}\n\n-- Get view value\nfunction tools.getView(self, name, typ)\n\tlocal function find(s)\n\t\tif type(s) == 'table' then\n\t\t\tif s.name == name then\n\t\t\t\treturn s[typ]\n\t\t\telse\n\t\t\t\tfor _,v in pairs(s) do\n\t\t\t\t\tlocal r = find(v)\n\t\t\t\t\tif r then\n\t\t\t\t\t\treturn r\n\t\t\t\t\tend\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\n\tlocal id = type(self) == \"userdata\" and self ~= tools and self.id or type(self) == \"number\" and self > 0 and self\n\tif id then\n\t\treturn find(api.get(\"/plugins/getView?id=\"..tostring(id))[\"$jason\"].body.sections)\n\tend\nend\n\n-- Check global variable existence\nfunction tools:checkVG(vg)\n\tif type(vg) == \"string\" and vg ~= \"\" then\n\t\tlocal response, status = api.get(\"/globalVariables/\" .. vg)\n\t\tif type(status) == \"number\" and (status == 200 or status == 201) and type(response) == \"table\" then\n\t\t\tif not response.name or response.name ~= vg then\n\t\t\t\treturn false\n\t\t\tend\n\t\telse\n\t\t\treturn false\n\t\tend\n\t\treturn true\n\telse\n\t\treturn false\n\tend\nend\n\n-- Create global variable\nfunction tools:createVG(varName, varValue, varEnum)\n\tif type(varName) == \"string\" and varName ~= \"\" then\n\t\tlocal payload = {name = varName, value = varValue or \"\"}\n\t\tlocal response, status = api.post(\"/globalVariables\", payload)\n\t\tif type(status) == \"number\" and (status == 200 or status == 201) and type(response) == \"table\" then\n\t\t\tif type(varEnum) == \"table\" and #varEnum > 0 then\n\t\t\t\tlocal payload = {name = varName, value = varValue or \"\", isEnum = true, enumValues = varEnum}\n\t\t\t\tlocal response, status = api.put(\"/globalVariables/\"..varName, payload)\n\t\t\t\tif type(status) == \"number\" and (status == 200 or status == 201) and type(response) == \"table\" then\n\t\t\t\t\treturn true\n\t\t\t\tend\n\t\t\telse\n\t\t\t    return true\n\t\t\tend\n\t\tend\n\tend\n\treturn false\nend\n\n-- Change global variable value\nfunction tools:setVG(vg, value)\n\tif type(vg) == \"string\" and vg ~= \"\" then\n\t\tlocal oldvalue = fibaro.getGlobalVariable(vg)\n\t\tif oldvalue ~= value then\n\t\t\tfibaro.setGlobalVariable(vg, value)\n\t\t\treturn true\n\t\tend\n\tend\n\treturn false\nend\n"}]}
